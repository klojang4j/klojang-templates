<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RenderSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Klojang Templates</a> &gt; <a href="index.source.html" class="el_package">org.klojang.templates</a> &gt; <span class="el_source">RenderSession.java</span></div><h1>RenderSession.java</h1><pre class="source lang-java linenums">package org.klojang.templates;

import org.klojang.check.Check;
import org.klojang.templates.x.parse.VariablePart;
import org.klojang.util.AnyTuple2;
import org.klojang.util.CollectionMethods;
import org.klojang.util.collection.IntList;

import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Stream;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Collections.singletonMap;
import static org.klojang.check.CommonChecks.*;
import static org.klojang.templates.Accessor.UNDEFINED;
import static org.klojang.templates.RenderException.*;
import static org.klojang.templates.TemplateUtils.getFQName;
import static org.klojang.templates.x.Messages.ERR_TEMPLATE_NAME_NULL;
import static org.klojang.util.ArrayMethods.EMPTY_STRING_ARRAY;
import static org.klojang.util.ObjectMethods.*;
import static org.klojang.util.StringMethods.concat;

/**
 * A {@code RenderSession} lets you populate a template and then render it. By
 * default template variables and nested templates are not rendered. That is, unless
 * you provide them with values, they will just disappear from the template upon
 * rendering. As soon as you render the template (by calling any of the
 * {@link #render()} methods), the {@code RenderSession} effectively becomes
 * immutable. You can render the template again using that {@code RenderSession}, as
 * often as you like, but it won't allow you to set or changes template variables any
 * longer.
 *
 * &lt;p&gt;Render sessions are throw-away objects that should go out of scope as quickly
 * as possible. They are cheap to instantiate, but can gain a lot of state as the
 * template gets populated. Therefore, when used within a JEE(-like) framework, make
 * sure they don't survive the request method. A possible exception could be
 * templates that render static but expensive-to-create content. However, in that
 * case it is better to {@link #createRenderable() obtain} a {@link Renderable}
 * object from the {@code RenderSession} and cache that, rather than the
 * {@code RenderSession} itself.
 *
 * &lt;h2&gt;Thead Safety&lt;/h2&gt;
 * &lt;p&gt;
 * A {@code RenderSession} carries a lot of state across its methods and is therefore
 * in principle not thread-safe. However, as long as different threads populate
 * different parts of the template (e.g. one thread populates the main table and
 * another thread does the rest), they cannot get in each other's way.
 *
 * @author Ayco Holleman
 */
public class RenderSession {

  private final SessionConfig config;
  private final RenderState state;

<span class="fc" id="L62">  RenderSession(SessionConfig config) {</span>
<span class="fc" id="L63">    this.config = config;</span>
<span class="fc" id="L64">    this.state = new RenderState(config);</span>
<span class="fc" id="L65">  }</span>

  /* METHODS FOR SETTING A SINGLE TEMPLATE VARIABLE */

  /**
   * Sets the specified variable to the specified value. Equivalent to
   * {@link #set(String, Object, VarGroup) set(varName, value, null)}.
   *
   * @param varName the name of the variable to set
   * @param value the value of the variable
   * @return this {@code RenderSession}
   */
  public RenderSession set(String varName, Object value) {
<span class="fc" id="L78">    return set(varName, value, null);</span>
  }

  /**
   * Sets the specified variable to the specified value, using the
   * {@link Stringifier stringifier} associated with the specified
   * {@link VarGroup variable group} to stringify the value. If the variable has an
   * inline group name prefix (e.g. ~%&lt;b&gt;html&lt;/b&gt;:fullName%), the group specified
   * through the prefix will prevail. The {@code varGroup} argument is allowed to be
   * {@code null}. In that case, if the variable also doesn't have an inline group
   * name prefix, the {@code RenderSession} will attempt to find a suitable
   * stringifier by other means; for example, based on the
   * {@link StringifierRegistry.Builder#registerByType(Stringifier, Class...) data
   * type} of the variable. If that fails, the {@code RenderSession} will default to
   * using the {@link Stringifier#DEFAULT default stringifier}.
   *
   * @param varName the name of the variable to set
   * @param value the value of the variable
   * @param varGroup the variable group to assign the variable to if the variable
   *     has no group name prefix. May be {@code null}.
   * @return this {@code RenderSession}
   * @see StringifierRegistry.Builder#registerByGroup(Stringifier, String...)
   */
  public RenderSession set(String varName, Object value, VarGroup varGroup) {
<span class="fc" id="L102">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="fc" id="L103">    Check.notNull(varName, &quot;varName&quot;);</span>
<span class="fc" id="L104">    Template t = config.getTemplate();</span>
<span class="fc" id="L105">    Check.that(t.getVariables()).is(contains(), varName, noSuchVariable(t, varName));</span>
<span class="fc" id="L106">    Check.on(alreadySet(t, varName), state.isSet(varName)).is(no());</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">    if (value == UNDEFINED) {</span>
      // Unless the user is manually going through, and accessing the properties
      // of some source data object, specifying UNDEFINED misses the point of that
      // constant, but since we can't know his, we'll have to accept that value
      // and process it as it is meant to be processed (namely: not).
<span class="nc" id="L112">      return this;</span>
    }
<span class="fc" id="L114">    IntList indices = config.getTemplate().getVarPartIndices().get(varName);</span>
<span class="fc" id="L115">    StringifierRegistry sf = config.getStringifiers();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">    for (int i = 0; i &lt; indices.size(); ++i) {</span>
<span class="fc" id="L117">      int partIndex = indices.get(i);</span>
<span class="fc" id="L118">      VariablePart part = t.getPart(partIndex);</span>
<span class="fc" id="L119">      Stringifier stringifier = sf.getStringifier(part, varGroup, value);</span>
<span class="fc" id="L120">      String stringified = stringify(stringifier, varName, value);</span>
<span class="fc" id="L121">      state.setVar(partIndex, new String[] {stringified});</span>
    }
<span class="fc" id="L123">    state.done(varName);</span>
<span class="fc" id="L124">    return this;</span>
  }

  /**
   * Sets the specified variable to the concatenation of the values within the
   * specified {@code List}. Unless the variable was declared with an inline group
   * name prefix, the values wil be stringified using the
   * {@link Stringifier#DEFAULT default stringifier}. The values are first
   * stringified, then escaped, then concatenated. If the {@code List} is empty, the
   * variable will not be rendered at all (that is, an empty string will be inserted
   * at the location of the variable within the template).
   *
   * @param varName the name of the template variable
   * @param values the string values to concatenate
   * @return this {@code RenderSession}
   */
  public RenderSession set(String varName, List&lt;?&gt; values) {
<span class="nc" id="L141">    return set(varName, values, (VarGroup) null);</span>
  }

  /**
   * Sets the specified variable to the concatenation of the values within the
   * specified {@code List}. The values in the {@code List} are first stringified and
   * then concatenated. If the {@code List} is empty, the variable will not be
   * rendered at all (that is, an empty string will be inserted at the location of
   * the variable within the template).
   *
   * @param varName the name of the template variable
   * @param values the string values to concatenate
   * @param varGroup the variable group to assign the variable to if the variable
   *     has no group name prefix
   * @return this {@code RenderSession}
   */
  public RenderSession set(String varName, List&lt;?&gt; values, VarGroup varGroup) {
<span class="fc" id="L158">    return set(varName, values, varGroup, null, null, null);</span>
  }

  /**
   * Sets the specified variable to the concatenation of the values within the
   * specified {@code List}, separating them using the specified separator string.
   *
   * @param varName the name of the template variable
   * @param values the string values to concatenate
   * @param separator the suffix to use for each string
   * @return this {@code RenderSession}
   * @see #set(String, List, VarGroup, String, String, String)
   */
  public RenderSession set(String varName, List&lt;?&gt; values, String separator) {
<span class="fc" id="L172">    return set(varName,</span>
        values,
        null,
        null,
        separator,
        null);
  }

  /**
   * Sets the specified variable to the concatenation of the values within the
   * specified {@code List}, separating them using the specified separator string.
   *
   * @param varName the name of the template variable
   * @param values the string values to concatenate
   * @param varGroup the variable group to assign the variable to if the variable
   *     has no group name prefix. May be {@code null}.
   * @param separator the suffix to use for each string
   * @return this {@code RenderSession}
   * @see #set(String, List, VarGroup, String, String, String)
   */
  public RenderSession set(String varName,
      List&lt;?&gt; values,
      VarGroup varGroup,
      String separator) {
<span class="fc" id="L196">    return set(varName, values, varGroup, null, separator, null);</span>
  }

  /**
   * Sets the specified variable to the concatenation of the values within the
   * specified {@code List}. For example:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * renderSession.set(&quot;myVar&quot;, List.of(&quot;&lt;&quot;, &quot;foo&quot;, &quot;&gt;&quot;), VarGroup.HTML, &quot;&lt;tr&gt;&lt;td&gt;&quot;, &quot;&lt;/td&gt;&lt;td&gt;&quot;, &quot;&lt;/td&gt;&lt;/tr&gt;&quot;);
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;will be rendered as:
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * &lt;tr&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;&lt;td&gt;foo&lt;/td&gt;&lt;td&gt;&amp;gt;&lt;/td&gt;&lt;/tr&gt;
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;The prefix, suffix and separator will not be escaped in any way. If the
   * {@code List} is empty, the variable, prefix, suffix and separator will not be
   * rendered at all.
   *
   * @param varName the name of the template variable
   * @param values the values to concatenate
   * @param varGroup the variable group to assign the variable to if the variable
   *     has no group name prefix. May be {@code null}
   * @param prefix the prefix to the first value
   * @param separator the separator between the values
   * @param suffix the suffix to the last value
   * @return this {@code RenderSession}
   */
  public RenderSession set(String varName,
      List&lt;?&gt; values,
      VarGroup varGroup,
      String prefix,
      String separator,
      String suffix) {
<span class="fc" id="L232">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="fc" id="L233">    Check.notNull(varName, &quot;varName&quot;);</span>
<span class="fc" id="L234">    Check.notNull(values, &quot;values&quot;);</span>
<span class="fc" id="L235">    Template t = config.getTemplate();</span>
<span class="fc" id="L236">    Check.that(t.getVariables()).is(contains(),</span>
        varName,
<span class="fc" id="L238">        noSuchVariable(t, varName));</span>
<span class="fc" id="L239">    Check.on(alreadySet(t, varName), state.isSet(varName)).is(no());</span>
<span class="fc" id="L240">    IntList indices = config.getTemplate().getVarPartIndices().get(varName);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    if (values.isEmpty()) {</span>
<span class="fc" id="L242">      indices.forEach(i -&gt; state.setVar(i, EMPTY_STRING_ARRAY));</span>
    } else {
<span class="fc" id="L244">      indices.forEachThrowing(i -&gt; setVar(i,</span>
          values,
          varGroup,
          prefix,
          separator,
          suffix));
    }
<span class="fc" id="L251">    state.done(varName);</span>
<span class="fc" id="L252">    return this;</span>
  }

  private void setVar(int partIndex,
      List&lt;?&gt; values,
      VarGroup defGroup,
      String prefix,
      String separator,
      String suffix) {
<span class="fc" id="L261">    VariablePart part = config.getTemplate().getPart(partIndex);</span>
<span class="fc" id="L262">    VarGroup varGroup = part.getVarGroup().orElse(defGroup);</span>
<span class="fc" id="L263">    prefix = n2e(prefix);</span>
<span class="fc" id="L264">    separator = n2e(separator);</span>
<span class="fc" id="L265">    suffix = n2e(suffix);</span>
<span class="pc bpc" id="L266" title="1 of 6 branches missed.">    boolean plain = prefix.isEmpty() &amp;&amp; separator.isEmpty() &amp;&amp; suffix.isEmpty();</span>
<span class="fc" id="L267">    StringifierRegistry sf = config.getStringifiers();</span>
    // Find first non-null value to increase the chance that we find a suitable
    // stringifier:
<span class="fc" id="L270">    Object any = values.stream().filter(notNull()).findFirst().orElse(null);</span>
<span class="fc" id="L271">    Stringifier stringifier = sf.getStringifier(part, varGroup, any);</span>
<span class="fc" id="L272">    String[] stringified = new String[values.size()];</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">    if (plain) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">      for (int i = 0; i &lt; values.size(); ++i) {</span>
<span class="fc" id="L275">        stringified[i] = stringify(stringifier, part.getName(), values.get(i));</span>
      }
    } else {
<span class="fc bfc" id="L278" title="All 2 branches covered.">      for (int i = 0; i &lt; values.size(); ++i) {</span>
<span class="fc" id="L279">        String s = stringify(stringifier, part.getName(), values.get(i));</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (i == 0) {</span>
<span class="fc" id="L281">          s = prefix + s;</span>
        }
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (i == values.size() - 1) {</span>
<span class="fc" id="L284">          s = s + suffix;</span>
        } else {
<span class="fc" id="L286">          s = s + separator;</span>
        }
<span class="fc" id="L288">        stringified[i] = s;</span>
      }
    }
<span class="fc" id="L291">    state.setVar(partIndex, stringified);</span>
<span class="fc" id="L292">  }</span>

  /**
   * Sets the specified variable to the entire output of the specified
   * {@code Renderable}. This allows you to create and populate a template for an
   * HTML snippet once, and then repeatedly (for each render session of the current
   * template) &quot;paste&quot; its output into the current template. See
   * {@link #createRenderable()}.
   *
   * @param varName the template variable to set
   * @param renderable the {@code Renderable}
   * @return this {@code RenderSession}
   */
  public RenderSession paste(String varName, Renderable renderable) {
<span class="nc" id="L306">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc" id="L307">    Check.on(illegalValue(&quot;varName&quot;, varName), varName).is(notNull());</span>
<span class="nc" id="L308">    Check.on(illegalValue(&quot;renderable&quot;, renderable), renderable).is(notNull());</span>
<span class="nc" id="L309">    Template t = config.getTemplate();</span>
<span class="nc" id="L310">    Check.that(t.getVariables()).is(contains(),</span>
        varName,
<span class="nc" id="L312">        noSuchVariable(t, varName));</span>
<span class="nc" id="L313">    Check.on(alreadySet(t, varName), state.isSet(varName)).is(no());</span>
<span class="nc" id="L314">    IntList indices = config.getTemplate().getVarPartIndices().get(varName);</span>
<span class="nc" id="L315">    indices.forEach(i -&gt; state.setVar(i, renderable));</span>
<span class="nc" id="L316">    return this;</span>
  }

  /* METHODS FOR POPULATING A SINGLE NESTED TEMPLATE */

  /**
   * Populates a template nested within the template being rendered by this
   * {@code RenderSession}. The template is populated with values retrieved from the
   * specified source data. Only variables and doubly-nested templates whose name is
   * present in the {@code names} argument will be populated. No escaping will be
   * applied to the values retrieved from the data object.
   *
   * @param nestedTemplateName the name of the nested template
   * @param sourceData an object that provides data for all or some of the nested
   *     template's variables and nested templates
   * @param names the names of the variables and doubly-nested templates that you
   *     want to be populated using the specified data object
   * @return this {@code RenderSession}
   */
  public RenderSession populate(String nestedTemplateName,
      Object sourceData,
      String... names) {
<span class="nc" id="L338">    return populate(nestedTemplateName, sourceData, null, names);</span>
  }

  /**
   * Populates a &lt;i&gt;nested&lt;/i&gt; template. The template is populated with values
   * retrieved from the specified source data. Only variables and (doubly) nested
   * templates whose name is present in the {@code names} argument will be
   * populated.
   *
   * &lt;h4&gt;Repeating Templates&lt;/h4&gt;
   *
   * &lt;p&gt;If the specified object is an array or a {@code Collection}, the template
   * will be repeated for each object in the array or {@code Collection}. This can be
   * used, for example, to generate an HTML table from a nested template that
   * contains just a single row.
   *
   * &lt;h4&gt;Conditional Rendering&lt;/h4&gt;
   *
   * &lt;p&gt;If the specified object is an empty array or an empty {@code Collection},
   * the template will not be rendered at all. This is the mechanism for conditional
   * rendering: &quot;populate&quot; the nested template with an empty array or
   * {@code Collection} and the template will not be rendered. Note, however, that
   * the same can be achieved more easily by just not calling the {@code populate}
   * method for that template as by default neither template variables nor nested
   * templates are rendered.
   *
   * @param nestedTemplateName the name of the nested template
   * @param sourceData an object that provides data for all or some of the nested
   *     template's variables and nested templates
   * @param varGroup the variable group to assign the variables to if they have
   *     no group name prefix. May be {@code null}.
   * @param names the names of the variables and doubly-nested templates that you
   *     want to be populated using the specified data object
   * @return this {@code RenderSession}
   */
  public RenderSession populate(String nestedTemplateName,
      Object sourceData,
      VarGroup varGroup,
      String... names) {
<span class="nc" id="L377">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">    if (sourceData == UNDEFINED) {</span>
<span class="nc" id="L379">      return this;</span>
    }
<span class="nc" id="L381">    Template t = getNestedTemplate(nestedTemplateName);</span>
<span class="nc" id="L382">    List&lt;?&gt; data = CollectionMethods.listify(sourceData);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    if (t.isTextOnly()) {</span>
<span class="nc" id="L384">      return show(data.size(), t);</span>
    }
<span class="nc" id="L386">    Check.on(missingSourceData(t), data).is(deepNotNull());</span>
<span class="nc" id="L387">    return repeat(t, data, varGroup, names);</span>
  }

  private RenderSession repeat(Template t,
      List&lt;?&gt; data,
      VarGroup defGroup,
      String... names) {
<span class="nc" id="L394">    RenderSession[] sessions = state.getOrCreateChildSessions(t, data.size());</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">    for (int i = 0; i &lt; sessions.length; ++i) {</span>
<span class="nc" id="L396">      sessions[i].insert(data.get(i), defGroup, names);</span>
    }
<span class="nc" id="L398">    return this;</span>
  }

  /**
   * Enables or disables the rendering of nested text-only templates. The specified
   * templates must all be text-only templates, otherwise a {@link RenderException}
   * is thrown. Equivalent to
   * {@link #show(int, String...) show(1, nestedTemplateNames)}.
   *
   * @param nestedTemplateNames the names of the nested templates to be
   *     rendered.
   * @return this {@code RenderSession}
   */
  public RenderSession show(String... nestedTemplateNames) {
<span class="nc" id="L412">    return show(1, nestedTemplateNames);</span>
  }

  /**
   * Enables or disables the rendering of nested text-only templates. A text-only
   * template is a template that does not contain any variables or nested templates.
   *
   * &lt;p&gt;To &lt;i&gt;disable&lt;/i&gt; rendering of a text-only template, specify 0 (zero) for
   * the {@code repeats} argument. Note, however, that by default template variables
   * and nested templates are not rendered in the first place, so you could also just
   * not call this method for the template in question.
   *
   * &lt;p&gt;Specify an empty {@code String} array ({@code new String[0]}) to enable
   * &lt;i&gt;all&lt;/i&gt; text-only templates that have not been explicitly enabled or
   * disabled yet. In that case, of course, it &lt;i&gt;does&lt;/i&gt; make sense to first
   * explicitly disable the text-only templates that should not be rendered.
   *
   * &lt;p&gt;You could achieve the same by calling
   * {@code populate(nestedTemplateName, null} or
   * {@code populate(nestedTemplateName, new Object[6]} (repeat six times) or
   * {@code populate(nestedTemplateName, new Object[0]} (disable the template).
   * However, the {@code show} method bypasses some code that is irrelevant to
   * text-only templates.
   *
   * @param repeats the number of times the nested template must be repeated
   * @param nestedTemplateNames the names of the nested text-only templates you
   *     want to be rendered
   * @return this {@code RenderSession}
   */
  public RenderSession show(int repeats, String... nestedTemplateNames) {
<span class="nc" id="L442">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc" id="L443">    Check.that(repeats, &quot;repeats&quot;).is(gte(), 0);</span>
<span class="nc" id="L444">    Check.notNull(nestedTemplateNames, &quot;nestedTemplateNames&quot;);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">    if (nestedTemplateNames.length == 0) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">      for (Template t : config.getTemplate().getNestedTemplates()) {</span>
<span class="nc bnc" id="L447" title="All 4 branches missed.">        if (t.isTextOnly() &amp;&amp; !state.isProcessed(t)) {</span>
<span class="nc" id="L448">          show(repeats, t);</span>
        }
<span class="nc" id="L450">      }</span>
    } else {
<span class="nc bnc" id="L452" title="All 2 branches missed.">      for (String name : nestedTemplateNames) {</span>
<span class="nc" id="L453">        Check.that(name).is(notNull(), &quot;Template name must not be null&quot;);</span>
<span class="nc" id="L454">        Template t = getNestedTemplate(name);</span>
<span class="nc" id="L455">        Check.on(notTextOnly(t), t.isTextOnly()).is(yes());</span>
<span class="nc" id="L456">        show(repeats, t);</span>
      }
    }
<span class="nc" id="L459">    return this;</span>
  }

  private RenderSession show(int repeats, Template nested) {
<span class="nc" id="L463">    state.getOrCreateTextOnlyChildSessions(nested, repeats);</span>
<span class="nc" id="L464">    return this;</span>
  }

  /**
   * Enables all nested text-only templates that have not been explicitly disabled
   * yet. The nested templates may in fact contain nested templates themselves, but
   * they must not contain variables at any nesting level beneath them. A
   * {@code RenderException} if they do.
   *
   * @param nestedTemplateNames the names of the nested text-only templates you
   *     want to be rendered
   * @return this {@code RenderSession}
   */
  public RenderSession showRecursive(String... nestedTemplateNames) {
<span class="nc" id="L478">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc" id="L479">    Check.notNull(nestedTemplateNames, &quot;nestedTemplateNames&quot;);</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">    if (nestedTemplateNames.length == 0) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">      for (Template t : config.getTemplate().getNestedTemplates()) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (!state.isDisabled(t)) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">          if (TemplateUtils.getVarsPerTemplate(t).isEmpty()) {</span>
<span class="nc" id="L484">            showRecursive(this, t);</span>
          }
        }
<span class="nc" id="L487">      }</span>
    } else {
<span class="nc bnc" id="L489" title="All 2 branches missed.">      for (String name : nestedTemplateNames) {</span>
<span class="nc" id="L490">        Check.that(name).is(notNull(), ERR_TEMPLATE_NAME_NULL);</span>
<span class="nc" id="L491">        Template t = getNestedTemplate(name);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (TemplateUtils.getVarsPerTemplate(t).isEmpty()) {</span>
<span class="nc" id="L493">          showRecursive(this, t);</span>
        }
      }
    }
<span class="nc" id="L497">    return this;</span>
  }

  private static void showRecursive(RenderSession s0, Template t0) {
<span class="nc" id="L501">    s0.show(1, t0);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">    if (!t0.getNestedTemplates().isEmpty()) {</span>
<span class="nc" id="L503">      RenderSession s = s0.state.getOrCreateChildSession(t0);</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">      for (Template t : t0.getNestedTemplates()) {</span>
<span class="nc" id="L505">        showRecursive(s, t);</span>
<span class="nc" id="L506">      }</span>
    }
<span class="nc" id="L508">  }</span>

  /**
   * Convenience method for populating a nested template that contains just one
   * variable and zero (doubly) nested templates. The variable may still occur
   * multiple times within the template. If the specified value is an array or a
   * {@code Collection}, the template is going to be repeated for each value within
   * the array or {@code Collection}.
   *
   * @param nestedTemplateName the name of the nested template. &lt;i&gt;Must&lt;/i&gt;
   *     contain exactly one variable
   * @param value the value to populate the nested template with
   * @return this {@code RenderSession}
   */
  public RenderSession populateWithValue(String nestedTemplateName, Object value) {
<span class="nc" id="L523">    return populateWithValue(nestedTemplateName, value, null);</span>
  }

  /**
   * Convenience method for populating a nested template that contains just one
   * variable and zero (doubly) nested templates. The variable may still occur
   * multiple times within the template. If the specified value is an array or a
   * {@code Collection}, the template is going to be repeated for each value within
   * the array or {@code Collection}.
   *
   * @param nestedTemplateName the name of the nested template. &lt;i&gt;Must&lt;/i&gt;
   *     contain exactly one variable
   * @param value the value to set the template's one and only variable to
   * @param varGroup the variable group to assign the variable to if the variable
   *     has no group name prefix. May be {@code null}.
   * @return this {@code RenderSession}
   */
  public RenderSession populateWithValue(String nestedTemplateName,
      Object value,
      VarGroup varGroup) {
<span class="nc" id="L543">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc" id="L544">    Template t = getNestedTemplate(nestedTemplateName);</span>
<span class="nc" id="L545">    Check.on(notMonoTemplate(t), t)</span>
<span class="nc" id="L546">        .has(tmpl -&gt; tmpl.getVariables().size(), eq(), 1)</span>
<span class="nc" id="L547">        .has(Template::countNestedTemplates, eq(), 0);</span>
<span class="nc" id="L548">    String var = t.getVariables().iterator().next();</span>
<span class="nc" id="L549">    List&lt;?&gt; values = Stream.of(value).map(v -&gt; singletonMap(var, v)).toList();</span>
<span class="nc" id="L550">    RenderSession[] sessions = state.getOrCreateChildSessions(t, values.size());</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">    for (int i = 0; i &lt; sessions.length; ++i) {</span>
<span class="nc" id="L552">      sessions[i].insert(values.get(i), varGroup);</span>
    }
<span class="nc" id="L554">    return this;</span>
  }

  /**
   * Convenience method for populating a nested template that contains just two
   * variables and zero (doubly) nested templates.
   *
   * @param nestedTemplateName the name of the nested template.
   * @param tuples a list of value pairs
   * @param &lt;T&gt; the type of the first input value
   * @param &lt;U&gt; the type of the second input value
   * @return this {@code RenderSession}
   */
  public &lt;T, U&gt; RenderSession populateWithTuple(String nestedTemplateName,
      List&lt;AnyTuple2&lt;T, U&gt;&gt; tuples) {
<span class="nc" id="L569">    return populateWithTuple(nestedTemplateName, tuples, null);</span>
  }

  /**
   * Convenience method for populating a nested template that contains just two
   * variables and zero (doubly) nested templates. The variables may still occur
   * multiple times within the template. The size of the list of tuples determines
   * how often the template is going to be repeated.
   *
   * @param nestedTemplateName the name of the nested template
   * @param tuples a list of value pairs
   * @param varGroup the variable group to assign the variables to if they have
   *     no group name prefix
   * @param &lt;T&gt; the type of the first input value
   * @param &lt;U&gt; the type of the second input value
   * @return this {@code RenderSession}
   */
  public &lt;T, U&gt; RenderSession populateWithTuple(String nestedTemplateName,
      List&lt;AnyTuple2&lt;T, U&gt;&gt; tuples,
      VarGroup varGroup) {
<span class="nc" id="L589">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc" id="L590">    Check.on(illegalValue(&quot;tuples&quot;, tuples), tuples).is(deepNotNull());</span>
<span class="nc" id="L591">    Template t = getNestedTemplate(nestedTemplateName);</span>
<span class="nc" id="L592">    Check.on(notTupleTemplate(t), t)</span>
<span class="nc" id="L593">        .has(tmpl -&gt; tmpl.getVariables().size(), eq(), 2)</span>
<span class="nc" id="L594">        .has(Template::countNestedTemplates, eq(), 0);</span>
<span class="nc" id="L595">    String[] vars = t.getVariables().toArray(new String[2]);</span>
<span class="nc" id="L596">    List&lt;Map&lt;String, Object&gt;&gt; data = tuples.stream()</span>
<span class="nc" id="L597">        .map(tuple -&gt; Map.of(vars[0], tuple.first(), vars[1], tuple.second()))</span>
<span class="nc" id="L598">        .toList();</span>
<span class="nc" id="L599">    RenderSession[] sessions = state.getOrCreateChildSessions(t, data.size());</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">    for (int i = 0; i &lt; sessions.length; ++i) {</span>
<span class="nc" id="L601">      sessions[i].insert(data.get(i), varGroup);</span>
    }
<span class="nc" id="L603">    return this;</span>
  }

  /* METHODS FOR POPULATING WHATEVER IS IN THE PROVIDED OBJECT */

  /**
   * Populates the &lt;i&gt;current&lt;/i&gt; template (the template for which this
   * {@code RenderSession} was created). No escaping will be applied to the values
   * extracted from the source data.
   *
   * @param sourceData an object that provides data for all or some of the
   *     template variables and nested templates
   * @param names the names of the variables nested templates names that must be
   *     populated. Not specifying any name (or {@code null}) indicates that you want
   *     all variables and nested templates to be populated.
   * @return this {@code RenderSession}
   */
  public RenderSession insert(Object sourceData, String... names) {
<span class="nc" id="L621">    return insert(sourceData, null, names);</span>
  }

  /**
   * Populates the &lt;i&gt;current&lt;/i&gt; template (the template for which this
   * {@code RenderSession} was created) using the provided source data object. The
   * source data object is not required to populate the entire template in one shot.
   * You can call this and similar methods multiple times until you are satisfied and
   * ready to {@link #render(OutputStream) render} the template.
   *
   * @param sourceData an object that provides data for all or some of the
   *     template variables and nested templates
   * @param varGroup the variable group to assign the variables to if they have
   *     no group name prefix. May be {@code null}.
   * @param names the names of the variables nested templates names that must be
   *     populated. Not specifying any name (or {@code null}) indicates that you want
   *     all variables and nested templates to be populated.
   * @return this {@code RenderSession}
   */
  public RenderSession insert(Object sourceData,
      VarGroup varGroup,
      String... names) {
<span class="nc" id="L643">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">    if (sourceData == UNDEFINED) {</span>
<span class="nc" id="L645">      return this;</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">    } else if (sourceData == null) {</span>
<span class="nc" id="L647">      Template t = config.getTemplate();</span>
<span class="nc" id="L648">      Check.on(notTextOnly(t), t.isTextOnly()).is(yes());</span>
      // If we get past this check, the entire template is in fact
      // static HTML. Expensive way to render static HTML, but no
      // reason not to support it.
<span class="nc" id="L652">      return this;</span>
    }
<span class="nc" id="L654">    processVars(sourceData, varGroup, names);</span>
<span class="nc" id="L655">    processTmpls(sourceData, varGroup, names);</span>
<span class="nc" id="L656">    return this;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  private &lt;T&gt; void processVars(T data, VarGroup defGroup, String[] names) {
    Set&lt;String&gt; varNames;
<span class="nc bnc" id="L662" title="All 2 branches missed.">    if (isEmpty(names)) {</span>
<span class="nc" id="L663">      varNames = config.getTemplate().getVariables();</span>
    } else {
<span class="nc" id="L665">      varNames = new HashSet&lt;&gt;(config.getTemplate().getVariables());</span>
<span class="nc" id="L666">      varNames.retainAll(List.of(names));</span>
    }
<span class="nc" id="L668">    Accessor&lt;T&gt; acc = (Accessor&lt;T&gt;) config.getAccessor(data);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">    for (String varName : varNames) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">      if (!state.isSet(varName)) {</span>
        Object value;
        try {
<span class="nc" id="L673">          value = acc.access(data, varName);</span>
<span class="nc" id="L674">        } catch (RuntimeException e) {</span>
<span class="nc" id="L675">          throw accessException(config.getTemplate(), varName, e, data, acc);</span>
<span class="nc" id="L676">        }</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">        if (value != UNDEFINED) {</span>
<span class="nc" id="L678">          set(varName, value, defGroup);</span>
        }
      }
<span class="nc" id="L681">    }</span>
<span class="nc" id="L682">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  private &lt;T&gt; void processTmpls(T data, VarGroup varGroup, String[] names) {
    Set&lt;String&gt; tmplNames;
<span class="nc bnc" id="L687" title="All 2 branches missed.">    if (isEmpty(names)) {</span>
<span class="nc" id="L688">      tmplNames = config.getTemplate().getNestedTemplateNames();</span>
    } else {
<span class="nc" id="L690">      tmplNames = new HashSet&lt;&gt;(config.getTemplate().getNestedTemplateNames());</span>
<span class="nc" id="L691">      tmplNames.retainAll(List.of(names));</span>
    }
<span class="nc" id="L693">    Accessor&lt;T&gt; acc = (Accessor&lt;T&gt;) config.getAccessor(data);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">    for (String name : tmplNames) {</span>
<span class="nc" id="L695">      Object nestedData = acc.access(data, name);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">      if (nestedData != UNDEFINED) {</span>
<span class="nc" id="L697">        populate(name, nestedData, varGroup, names);</span>
      }
<span class="nc" id="L699">    }</span>
<span class="nc" id="L700">  }</span>

  /* MISCELLANEOUS METHODS */

  /**
   * Returns a {@code RenderSession} for the specified nested template. The
   * {@code RenderSession} inherits the {@link AccessorRegistry accessors} and
   * {@link StringifierRegistry stringifiers} from the parent session (i.e.
   * &lt;i&gt;this&lt;/i&gt; {@code RenderSession}). If this is the first time the nested
   * template is processed, a single child session will be created for it. This can
   * be used as illustrated in the following example (assuming the presence of a
   * nested template named {@code employees}):
   *
   * &lt;blockquote&gt;&lt;pre&gt;{@code
   * session.in(&quot;employees&quot;).set(&quot;firstName&quot;, &quot;john&quot;).set(&quot;lastName&quot;, &quot;Smith&quot;);
   * }&lt;/pre&gt;&lt;/blockquote&gt;
   *
   * &lt;p&gt;Note that just calling the {@code in} method already has the effect of the
   * template becoming visible.
   *
   * @param nestedTemplateName the nested template for which to create the child
   *     session
   * @return A child session that you can (and should) populate yourself
   */
  public RenderSession in(String nestedTemplateName) {
<span class="nc" id="L725">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc" id="L726">    Template t = getNestedTemplate(nestedTemplateName);</span>
<span class="nc" id="L727">    return state.getOrCreateChildSession(t);</span>
  }

  /**
   * Returns the child sessions that have been created for the specified nested
   * template. This method throws a {@code RenderException} if no child sessions have
   * been created yet for the specified nested template.
   *
   * @param nestedTemplateName the nested template
   * @return A {@code List} of child sessions
   */
  public List&lt;RenderSession&gt; getChildSessions(String nestedTemplateName) {
<span class="nc" id="L739">    Check.on(frozenSession(), state.isFrozen()).is(no());</span>
<span class="nc" id="L740">    Template t = getNestedTemplate(nestedTemplateName);</span>
<span class="nc" id="L741">    RenderSession[] sessions = state.getChildSessions(t);</span>
<span class="nc" id="L742">    Check.on(noChildSessionsYet(t), t).is(notNull());</span>
<span class="nc" id="L743">    return List.of(sessions);</span>
  }

  /* RENDER METHODS */

  /**
   * Returns {@code true} if the template is fully populated. That is, all template
   * variables (nested or not) have been. Note that you may not &lt;i&gt;want&lt;/i&gt; the
   * template to be fully populated.
   *
   * @return {@code true} if the template is fully populated
   */
  public boolean isFullyPopulated() {
<span class="nc" id="L756">    return state.isFullyPopulated();</span>
  }

  /**
   * Returns a {@code Renderable} instance that allows you to render the current
   * template over and over again. See {@link #paste(String, Renderable)}.
   *
   * @return A {@code Renderable} instance allows you to render the current template
   */
  public Renderable createRenderable() {
<span class="fc" id="L766">    state.freeze();</span>
<span class="fc" id="L767">    return new RenderableImpl(state);</span>
  }

  /**
   * Writes the render result to the specified {@code OutputStream}. Shortcut for
   * {@code createRenderable().render(out)}.
   *
   * @param out the output stream to which to write the render result
   */
  public void render(OutputStream out) {
<span class="nc" id="L777">    createRenderable().render(out);</span>
<span class="nc" id="L778">  }</span>

  /**
   * Appends the render result to the specified {@code StringBuilder}. Shortcut for
   * {@code createRenderable().render(sb)}.
   *
   * @param sb the {@code StringBuilder} to which to append the render result
   */
  public void render(StringBuilder sb) {
<span class="nc" id="L787">    createRenderable().render(sb);</span>
<span class="nc" id="L788">  }</span>

  /**
   * Returns the render result as a UTF-8 encoded {@code String}.
   *
   * @return the render result
   */
  public String render() {
<span class="fc" id="L796">    ByteArrayOutputStream out = new ByteArrayOutputStream(1024);</span>
<span class="fc" id="L797">    createRenderable().render(out);</span>
<span class="fc" id="L798">    return out.toString(UTF_8);</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L803">    return concat(getClass().getSimpleName(),</span>
        &quot; &quot;,
<span class="nc" id="L805">        System.identityHashCode(this),</span>
        &quot; for template &quot;,
<span class="nc" id="L807">        getFQName(config.getTemplate()),</span>
        &quot; (&quot;,
<span class="nc" id="L809">        ifNull(config.getTemplate().getPath(), &quot;inline&quot;),</span>
        &quot;)&quot;);
  }

  RenderState getState() {
<span class="nc" id="L814">    return state;</span>
  }

  private Template getNestedTemplate(String name) {
<span class="nc" id="L818">    Check.notNull(name, &quot;nestedTemplateName&quot;);</span>
<span class="nc" id="L819">    Check.on(noSuchTemplate(config.getTemplate(), name), name)</span>
<span class="nc" id="L820">        .is(validTemplateName());</span>
<span class="nc" id="L821">    return config.getTemplate().getNestedTemplate(name);</span>
  }

  private Predicate&lt;String&gt; validTemplateName() {
<span class="nc" id="L825">    return s -&gt; config.getTemplate().getNestedTemplateNames().contains(s);</span>
  }

  private String stringify(Stringifier stringifier, String varName, Object value) {
    try {
<span class="fc" id="L830">      String s = stringifier.toString(value);</span>
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">      if (s == null) {</span>
<span class="nc" id="L832">        throw BadStringifierException.stringifierReturnedNull(config.getTemplate(),</span>
            varName);
      }
<span class="fc" id="L835">      return s;</span>
<span class="nc" id="L836">    } catch (NullPointerException e) {</span>
<span class="nc" id="L837">      throw BadStringifierException.stringifierNotNullResistant(config.getTemplate(),</span>
          varName);
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>